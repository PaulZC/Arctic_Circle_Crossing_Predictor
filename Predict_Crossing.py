# Predict_Crossing.py
#
# By: Paul Clark (PaulZC), November 24th 2024
#
# Licence: MIT
#
# Using the pickle file generated by Extract_Data.py for a previous sailing,
# this code predicts the time of the Arctic Crossing based on the scheduled
# time of arrival, distance remaining and average speed needed to arrive on time.

from datetime import datetime, timedelta
import pytz # pip install pytz
import urllib.request
from time import sleep
import pickle
import json

class PredictCrossing():
    def __init__(self):
        self.arrivalTime = None
        self.userkey = ''
        self.inputPickleFile = None
        self.pickleJar = {}
        self.vessel = 0

    def setArrivalTime(self, tz, arrival):
        arrivalTime = {
            'tz': tz,
            'arrival': arrival
        }
        self.arrivalTime = arrivalTime

    def setUserKey(self, key):
        self.userkey = key

    def setInputPickleFilename(self, filename):
        self.inputPickleFile = filename

    def setVessel(self, IMO):
        self.vessel = IMO

    def predict(self):
        if self.arrivalTime is None:
            return
        
        if self.inputPickleFile is None:
            return
        
        # Load the pickle file
        with open(self.inputPickleFile, 'rb') as f:
            self.pickleJar = pickle.load(f)
        
        while True:

            # Construct the URL for the VESSELS API request
            request = "https://api.vesselfinder.com/vessels?userkey="
            request += self.userkey
            request += "&imo="
            request += str(self.vessel)
            print("Request : " + request)

            result = None
            try:
                result = urllib.request.urlopen(request).read().decode("utf-8")
            except:
                print("URL request error!")

            if result is not None and 'AIS' in result:
                # Write result to file
                dt = datetime.now(pytz.UTC) # Use UTC for the file name
                filename = dt.strftime("Track_Vessel_UTC_%Y-%m-%d_%H-%M-%S.json")
                with open(filename, 'w') as f:
                    f.write(result)
                print("Wrote JSON to " + filename + " :")
                print(result)

                # Calculate the time until arrival
                jsonData = json.loads(result)
                for ais in jsonData: # Each file could contain multiple AIS entries
                    #print(ais)
                    DTnow = pytz.timezone('UTC').localize(datetime.strptime(ais['AIS']['TIMESTAMP'], "%Y-%m-%d %H:%M:%S UTC"))
                    DTarrival = pytz.timezone(self.arrivalTime['tz']).localize(datetime.strptime(self.arrivalTime['arrival'], "%Y-%m-%d %H:%M:%S"))

                    timeToArrivalDelta = DTarrival - DTnow
                    daysToArrival, rem = divmod(timeToArrivalDelta.total_seconds(), 60 * 60 * 24)
                    hoursToArrival, rem = divmod(rem, 60 * 60)
                    minutesToArrival, secondsToArrival = divmod(rem, 60)                    
                    print("Time to arrival                 : {:.0f} Days, {:02.0f}:{:02.0f}:{:02.0f}".format(daysToArrival, hoursToArrival, minutesToArrival, secondsToArrival))

                    # Find the entry in pickleJar with the closest Latitude
                    deltaLat = 90.0
                    closestEntry = None
                    for DT in self.pickleJar.keys():
                        if abs(self.pickleJar[DT]['LATITUDE'] - ais['AIS']['LATITUDE']) < deltaLat:
                            deltaLat = abs(self.pickleJar[DT]['LATITUDE'] - ais['AIS']['LATITUDE'])
                            closestEntry = DT

                    if closestEntry is None:
                        break

                    distanceToDestination = self.pickleJar[closestEntry]['REMAINING_NM']
                    print("Distance to destination (NM)    : {:.1f}".format(distanceToDestination))
                    distanceToCircle = self.pickleJar[closestEntry]['CIRCLE_NM']
                    print("Distance to Arctic Circle (NM)  : {:.1f}".format(distanceToCircle))

                    speedToDestination = distanceToDestination / timeToArrivalDelta.total_seconds()
                    print("Speed to arrive on time (Knots) : {:.1f}".format(speedToDestination))

                    timeToCircle = distanceToCircle / speedToDestination
                    crossingTime = DTnow + timedelta(seconds = timeToCircle)
                    print("Crossing Time                   : {}".format(crossingTime.replace(tzinfo=pytz.timezone('UTC')) \
                                      .astimezone(pytz.timezone(self.arrivalTime['tz'])).strftime('%Y-%m-%d %H:%M:%S'), self.arrivalTime['tz']))
                    print()



            # Repeat every 60 seconds until arrival time has expired
            sleep(60)
            
if __name__ == '__main__':

    predict = PredictCrossing()

    # Set the user key
    predict.setUserKey('<ADD YOUR KEY HERE>')

    predict.setVessel(9107796) # MS Polarlys

    # Set the scheduled arrival time
    # timezone is in pytz format. See pytz.all_timezones
    # arrival is in YYYY-MM-DD HH:MM:SS format
    predict.setArrivalTime('Europe/Oslo', '2024-12-04 10:00:00')

    predict.setInputPickleFilename('Track_Vessel_9107796.pkl')

    predict.predict()
